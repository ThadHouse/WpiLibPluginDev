import org.gradle.internal.os.OperatingSystem

plugins {
    id 'net.ltgt.errorprone' version '0.0.8'
    id 'edu.wpi.first.wpilib.versioning.WPILibVersioningPlugin' version '1.1'
}

allprojects {
    repositories {
        mavenCentral()
    }
}

// Determine what repo to publish to. Default is development. Valid options are development, beta, stable, and release
if (!hasProperty('repo')) {
    allprojects {
        ext.repo = 'development'
    }
}

ext.buildDesktop =project.hasProperty('desktop')
ext.buildArm = !project.hasProperty('skipArm')
ext.includeJava = !project.hasProperty('skipJava')

if (hasProperty('makeDesktop')) {
    println 'Making desktop classifier jar. NOTE: This desktop version should only be used for local testing.' +
            'It will only support the current platform, and will override fetching the latest development version from' +
            ' the maven repo until you manually delete it!'
}

ext.getPlatformPath = { binary ->
    if (binary.targetPlatform.architecture.arm) {
        return 'Linux/arm'
    } else if (binary.targetPlatform.operatingSystem.linux) {
        if (binary.targetPlatform.architecture.amd64) {
            return 'Linux/amd64'
        } else {
            return 'Linux/' + binary.targetPlatform.architecture.name
        }
    } else if (binary.targetPlatform.operatingSystem.windows) {
        if (binary.targetPlatform.architecture.amd64) {
            return 'Windows/amd64'
        } else {
            return 'Windows/' + binary.targetPlatform.architecture.name
        }
    } else if (binary.targetPlatform.operatingSystem.macOsX) {
        if (binary.targetPlatform.architecture.amd64) {
            return 'Mac OS X/x86_64'
        } else {
            return 'Mac OS X/' + binary.targetPlatform.architecture.name
        }
    } else {
        return binary.targetPlatform.operatingSystem.name + '/' + binary.targetPlatform.architecture.name
    }
}

ext.setupDefines = { project, binaries ->
    binaries.all {
	if (project.hasProperty('debug')) {
	    project.setupDebugDefines(cppCompiler, linker)
	} else {
	    project.setupReleaseDefines(cppCompiler, linker)
	}
    }
}

ext.addUserLinks = { linker, targetPlatform ->
  def libPattern = /.*((\\/|\\).*)+lib(?<libName>.+).so$/
                def niLibraryArgs = []
                def niLibraryPath = file('libraries').path

                // The NI Library tree includes all non-wpi libraries, which is everything that doesn't have libwpi in the name
                def niLibraryTree = fileTree(niLibraryPath)
                niLibraryTree.include '*.so'
                niLibraryTree.exclude '*wpi*.so'
                
                // This adds all linker flags to the list of ni library linker flags
                niLibraryTree.each { lib ->
                    def nameMatcher = (lib.path =~ libPattern)
                    if (nameMatcher[0].size() > 1) {
                        def name = nameMatcher.group('libName')
                        niLibraryArgs << '-l' + name
                    }
                }

            String architecture = targetPlatform.architecture
            if (architecture.contains('arm')){
                linker.args << '-L' + niLibraryPath
                linker.args.addAll(niLibraryArgs)
            }
        }

ext.addWpiLibLink = { linker, targetPlatform ->
    def niLibraryPath = file('wpilib').path
    def libLoc = "$niLibraryPath/lib/libwpilib_nonshared.a"
    
    linker.args libLoc
}

def wpilibUnzipLocation = "$buildDir/wpilib"

task downloadWpilib() {
    description = 'Downloads the C++ ARM wpiutil maven dependency.'

    group = 'WPILib'
    def depFolder = "$buildDir/dependencies"
    def utilZip = file("$depFolder/cpp-root.zip")
    outputs.file(utilZip)
    def armWPILib
    
    println("WPILib download")

    doFirst {
        println("Do First")
        def armWpiUtilDependency = project.dependencies.create("edu.wpi.first.wpilib.cmake:cpp-root:+")
        def armWpiUtilConfig = project.configurations.detachedConfiguration(armWpiUtilDependency)
        armWpiUtilConfig.setTransitive(false)
        armWPILib = armWpiUtilConfig.files[0].canonicalFile
    }

    doLast {
        println("Do Last")
        copy {
            from armWPILib
            rename 'cpp-root(.+)', 'cpp-root.zip'
            into depFolder
        }
    }
}

// Create a task that will unzip the wpiutil files into a temporary build directory
task unzipWpilib(type: Copy) {
    description = 'Unzips the wpiutil maven dependency so that the include files and libraries can be used'
    group = 'WPILib'
    dependsOn downloadWpilib
    println("unzip")
    println(wpilibUnzipLocation)
    
    def f = downloadWpilib.outputs.files.singleFile
    
    println(f)

    from zipTree(f)
    into wpilibUnzipLocation
}

task clean(type: Delete) {
    description = "Deletes the build directory"
    group = "Build"
    delete buildDir
}

ext.defineWpiLibProperties = {
  ext.wpilib = wpilibUnzipLocation
  ext.wpilibInclude = "$wpilibUnzipLocation/include"
  ext.wpilibLocation = "$wpilibUnzipLocation/lib"
  ext.wpilibStaticLib = "$wpilibLocation/libwpilib_nonshared.a"
  ext.halStaticLib = "$wpilibLocation/libHALAthena.a"
  ext.ntcoreStaticLib = "$wpilibLocation/libntcore.a"
  ext.wpiUtilStaticLib = "$wpilibLocation/libwpiutil.a"
  
  ext.addWpilibLibraryLinks = { compileTask, linker, targetPlatform ->
    compileTask.dependsOn project(':').unzipWpilib
    String architecture = targetPlatform.architecture
    if (architecture.contains('arm')) {
      // Grab all the shared libraries and link them
            linker.args wpilibStaticLib
      linker.args halStaticLib
      linker.args ntcoreStaticLib
      linker.args wpiUtilStaticLib
      
      def libPattern = /.*((\\/|\\).*)+lib(?<libName>.+).so$/
                def niLibraryArgs = []
                def niLibraryPath = wpilibLocation

                // The NI Library tree includes all non-wpi libraries, which is everything that doesn't have libwpi in the name
                def niLibraryTree = fileTree(niLibraryPath)
                niLibraryTree.include '*.so'
                niLibraryTree.exclude '*wpi*.so'
                niLibraryTree.exclude '*_shared.so'
                
                
                // This adds all linker flags to the list of ni library linker flags
                niLibraryTree.each { lib ->
                    def nameMatcher = (lib.path =~ libPattern)
                    if (nameMatcher[0].size() > 1) {
                        def name = nameMatcher.group('libName')
                        niLibraryArgs << '-l' + name
                    }
                }
                
                linker.args << '-L' + niLibraryPath
                linker.args.addAll(niLibraryArgs)
      

    }
  }
}


apply from: "impl.gradle"
apply from: "driver.gradle"

// Empty task for build so that ntcoreSourceZip and driverSourceZip will be
// built when running ./gradlew build
task build

build.dependsOn implSourceZip
build.dependsOn driverSourceZip

//apply from: 'publish.gradle'

task wrapper(type: Wrapper) {
    gradleVersion = '3.0'
}
